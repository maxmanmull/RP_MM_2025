#!/usr/bin/env python3
"""
Analysis Script with Biocyc
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import seaborn as sns
from matplotlib.lines import Line2D
from upsetplot import UpSet, from_contents
from scipy.stats import fisher_exact
from statsmodels.stats.multitest import multipletests
import warnings

warnings.filterwarnings('ignore')

# ==================== FILE PATHS ====================
PATHWAY_FILE = r".\meta_rea_pwy-gapseq.tbl" #get from gapseq git repo

# Input files (generated by Metabolic_Modeling.py)
INPUT_GROWTH_RATES = 'growth_rates.csv'
INPUT_EXCHANGE_FLUXES = 'exchange_fluxes.csv'
INPUT_COMPREHENSIVE = 'reaction_analysis.csv'

# ==================== DATABASES ====================

# Deep Sea Ocean Color Palettes
DEEPSEA_PRIMARY = {
    'abyss': '#0c1b33',
    'midnight': '#1e3a5f',
    'deep_blue': '#234e70',
    'ocean': '#2c5f8e',
    'twilight': '#3875a8',
    'marine': '#4a90c2',
    'reef': '#5fa8d3',
    'lagoon': '#7bbee8',
    'shallow': '#9dd1f1',
    'seafoam': '#bde4f4',
    'biolume_green': '#00ffc3',
    'biolume_cyan': '#00e5ff',
}

DEEPSEA_SECONDARY = {
    'pearl': '#f8f9fa',
    'shell': '#e9ecef',
    'fog': '#dee2e6',
    'stone': '#adb5bd',
    'depth': '#6c757d',
    'trench': '#495057',
    'void': '#343a40',
    'ink': '#212529',
    'jellyfish': '#e4c1f9',
    'urchin': '#d0b8e3',
    'starfish': '#fcb1a6',
    'current': '#a9def9',
    'wave': '#d0f4de',
    'plankton': '#fcf6bd',
}

# Phylum Colors
PHYLUM_COLORS = {
    'Pseudomonadota': DEEPSEA_SECONDARY['current'],
    'Acidobacteriota': DEEPSEA_SECONDARY['wave'],
    'Bacteroidota': DEEPSEA_SECONDARY['jellyfish'],
    'Actinomycetota': DEEPSEA_SECONDARY['starfish']
}

# Organism to Genome Mapping
ORGANISM_GENOME_MAPPING = {
    'Vreelandella_maris': '12_genome',
    'Alloalcanivorax_venustensis': '163_9',
    'Pseudoalteromonas_tetraodonis': '1_genome',
    'Cobetia_amphilecti': '291_genome',
    'Pseudomonas_E_sp': '2_genome',
    'Marinobacter_sp': '336_genome',
    'Polaribacter_sp': '3_genome',
    'Paraglaciecola_sp': '459_genome',
    'Pseudovibrio_sp': '468_genome',
    'Halopseudomonas_neustonica': '482_12',
    'Salegentibacter_sp': '482_9',
    'Leeuwenhoekiella_aequorea': '4_genome',
    'Mycobacterium_sp': '536_0',
    'Gelidibacter_sp': '539_genome',
    'Methylophaga_sp002696735': '581_2',
    'Alloalcanivorax_sp002389055': '581_7',
    'Psychrobacter_sp': '5_genome',
    'Rhodoglobus_sp963974405': '6_genome',
    'Marinacidobacterium_sp': 'Marinacidobacteraceae'
}

# Genome to Organism Compact Display Names
GENOME_TO_ORGANISM_COMPACT = {
    '12_genome': 'Vreelandella_maris',
    '1_genome': 'Pseudoalteromonas_tetraodonis',
    '291_genome': 'Cobetia_amphilecti',
    '2_genome': 'Pseudomonas_E_sp',
    '336_genome': 'Marinobacter_sp',
    '3_genome': 'Polaribacter_sp',
    '459_genome': 'Paraglaciecola_sp',
    '468_genome': 'Pseudovibrio_sp',
    '4_genome': 'Leeuwenhoekiella_aequorea',
    '539_genome': 'Gelidibacter_sp',
    '5_genome': 'Psychrobacter_sp',
    '6_genome': 'Rhodoglobus_sp963974405',
    '12': 'Vreelandella_maris',
    '1': 'Pseudoalteromonas_tetraodonis',
    '291': 'Cobetia_amphilecti',
    '2': 'Pseudomonas_E_sp',
    '336': 'Marinobacter_sp',
    '3': 'Polaribacter_sp',
    '459': 'Paraglaciecola_sp',
    '468': 'Pseudovibrio_sp',
    '4': 'Leeuwenhoekiella_aequorea',
    '539': 'Gelidibacter_sp',
    '5': 'Psychrobacter_sp',
    '6': 'Rhodoglobus_sp963974405',
    '163_9': 'Alloalcanivorax_venustensis',
    '482_12': 'Halopseudomonas_neustonica',
    '482_9': 'Salegentibacter_sp',
    '536_0': 'Mycobacterium_sp',
    '581_2': 'Methylophaga_sp002696735',
    '581_7': 'Alloalcanivorax_sp002389055',
    'Marinacidobacteraceae': 'Marinacidobacterium_sp'
}

# Organism to Phylum Mapping
ORGANISM_PHYLUM = {
    'Vreelandella_maris': 'Pseudomonadota',
    'Alloalcanivorax_venustensis': 'Pseudomonadota',
    'Pseudoalteromonas_tetraodonis': 'Pseudomonadota',
    'Cobetia_amphilecti': 'Pseudomonadota',
    'Pseudomonas_E_sp': 'Pseudomonadota',
    'Marinobacter_sp': 'Pseudomonadota',
    'Polaribacter_sp': 'Bacteroidota',
    'Paraglaciecola_sp': 'Pseudomonadota',
    'Pseudovibrio_sp': 'Pseudomonadota',
    'Halopseudomonas_neustonica': 'Pseudomonadota',
    'Salegentibacter_sp': 'Bacteroidota',
    'Leeuwenhoekiella_aequorea': 'Bacteroidota',
    'Mycobacterium_sp': 'Actinomycetota',
    'Gelidibacter_sp': 'Bacteroidota',
    'Methylophaga_sp002696735': 'Pseudomonadota',
    'Alloalcanivorax_sp002389055': 'Pseudomonadota',
    'Psychrobacter_sp': 'Pseudomonadota',
    'Rhodoglobus_sp963974405': 'Actinomycetota',
    'Marinacidobacterium_sp': 'Acidobacteriota'
}

# ==================== STYLE SETTINGS ====================
plt.rcParams['font.family'] = 'Arial'
plt.rcParams['font.size'] = 11
plt.rcParams['axes.facecolor'] = DEEPSEA_SECONDARY['pearl']
plt.rcParams['figure.facecolor'] = 'white'


# ==================== ANALYZER CLASS ====================

class KnockoutUnifiedAnalyzer:
    def __init__(self):
        self.data = None
        self.growth_data = None
        self.flux_data = None
        self.pathway_enrichment = None
        self.pathway_mapping = {}
        self.unique_reactions = None
        self.background_reactions = None

        self.organism_genome_mapping = ORGANISM_GENOME_MAPPING
        self.genome_to_organism = {v: k for k, v in ORGANISM_GENOME_MAPPING.items()}
        self.genome_to_organism_compact = GENOME_TO_ORGANISM_COMPACT
        self.phylum_colors = PHYLUM_COLORS
        self.organism_phylum = ORGANISM_PHYLUM

    def get_organism_color(self, organism_name):
        """Get color for an organism based on its phylum."""
        phylum = self.organism_phylum.get(organism_name, None)
        return self.phylum_colors.get(phylum, DEEPSEA_SECONDARY['stone'])

    def load_knockout_data(self):
        """Load data files generated by Knockout.ipynb"""
        try:
            self.data = pd.read_csv(INPUT_COMPREHENSIVE)
            self.growth_data = pd.read_csv(INPUT_GROWTH_RATES)
            self.flux_data = pd.read_csv(INPUT_EXCHANGE_FLUXES)
        except FileNotFoundError:
            return False

        if not self.load_pathway_database():
            pass

        if not self.load_unique_reactions():
            return False

        if not self.load_background_reactions():
            return False

        if self.pathway_mapping:
            self.pathway_enrichment = self.perform_pathway_enrichment_analysis()

        return True

    def load_pathway_database(self):
        """Load SEED pathway database from gapseq file."""
        try:
            df = pd.read_csv(PATHWAY_FILE, sep='\t')

            for _, row in df.iterrows():
                pathway_name = row['pathway.name']
                gapseq_reactions = row['gapseq']

                if pd.notna(pathway_name) and pd.notna(gapseq_reactions):
                    reactions = str(gapseq_reactions).strip().split()

                    for reaction in reactions:
                        if reaction:
                            if reaction not in self.pathway_mapping:
                                self.pathway_mapping[reaction] = []
                            if pathway_name not in self.pathway_mapping[reaction]:
                                self.pathway_mapping[reaction].append(pathway_name)

            return True

        except FileNotFoundError:
            return False
        except Exception:
            return False

    def load_unique_reactions(self):
        """Load reactions that are uniquely gapfilled in Marinacidobacterium (constrained)."""
        try:
            marinacidobacterium_constrained = self.data[
                (self.data['Organism'] == 'Marinacidobacteraceae') &
                (self.data['Is_Gapfilled_Active_Highly_Constrained'] == True)
                ]

            if len(marinacidobacterium_constrained) == 0:
                self.unique_reactions = set()
                return True

            marinacidobacterium_reactions = set(marinacidobacterium_constrained['Reaction_ID'])

            other_organisms_gapfilled = self.data[
                (self.data['Organism'] != 'Marinacidobacteraceae') &
                (self.data['Is_Gapfilled'] == True)
                ]
            other_organisms_gapfilled_reactions = set(other_organisms_gapfilled['Reaction_ID'])

            uniquely_gapfilled_reactions = marinacidobacterium_reactions - other_organisms_gapfilled_reactions

            self.unique_reactions = set()
            for reaction_id in uniquely_gapfilled_reactions:
                base_id = reaction_id.split('_')[0]
                self.unique_reactions.add(base_id)

            return True

        except Exception:
            return False

    def load_background_reactions(self):
        """Load background reaction pool from highly constrained gapfilled reactions."""
        try:
            constrained_data = self.data[
                self.data['Is_Gapfilled_Active_Highly_Constrained'] == True
                ]

            self.background_reactions = set()
            for reaction_id in constrained_data['Reaction_ID'].unique():
                base_id = reaction_id.split('_')[0]
                self.background_reactions.add(base_id)

            return True

        except Exception:
            return False

    def perform_pathway_enrichment_analysis(self):
        """Perform pathway enrichment analysis using Fisher's exact test."""
        if not self.unique_reactions or not self.background_reactions:
            return None

        all_pathways = set()
        for pathways in self.pathway_mapping.values():
            all_pathways.update(pathways)

        results = []

        for pathway in all_pathways:
            pathway_reactions = set()
            for reaction, pathways in self.pathway_mapping.items():
                if pathway in pathways:
                    pathway_reactions.add(reaction)

            if len(pathway_reactions) == 0:
                continue

            unique_in_pathway = len(self.unique_reactions & pathway_reactions)
            unique_not_in_pathway = len(self.unique_reactions) - unique_in_pathway

            background_in_pathway = len(self.background_reactions & pathway_reactions)
            background_not_in_pathway = len(self.background_reactions) - background_in_pathway

            other_in_pathway = background_in_pathway - unique_in_pathway
            other_not_in_pathway = background_not_in_pathway - unique_not_in_pathway

            if unique_in_pathway > 0 and background_in_pathway > 0:
                contingency_table = [[unique_in_pathway, unique_not_in_pathway],
                                     [other_in_pathway, other_not_in_pathway]]

                odds_ratio, p_value = fisher_exact(contingency_table, alternative='greater')

                unique_rate = unique_in_pathway / len(self.unique_reactions) if len(self.unique_reactions) > 0 else 0
                background_rate = background_in_pathway / len(self.background_reactions) if len(
                    self.background_reactions) > 0 else 0
                fold_enrichment = unique_rate / background_rate if background_rate > 0 else 0

                results.append({
                    'Pathway': pathway,
                    'Unique_Count': unique_in_pathway,
                    'Background_Count': background_in_pathway,
                    'Unique_Total': len(self.unique_reactions),
                    'Background_Total': len(self.background_reactions),
                    'Unique_Rate': unique_rate,
                    'Background_Rate': background_rate,
                    'Fold_Enrichment': fold_enrichment,
                    'Odds_Ratio': odds_ratio,
                    'P_Value': p_value
                })

        if not results:
            return None

        df = pd.DataFrame(results)
        df = df.sort_values('P_Value')

        reject, pvals_corrected, _, _ = multipletests(df['P_Value'], method='fdr_bh')
        df['FDR_Corrected_P'] = pvals_corrected
        df['Significant_P005'] = df['P_Value'] < 0.05
        df['Significant_FDR005'] = df['FDR_Corrected_P'] < 0.05

        return df

    def plot_growth_rates(self, ax):
        """Plot growth rates with phylum-colored labels"""
        growth_plot = self.growth_data.copy()
        growth_plot['Name'] = growth_plot['Organism'].map(self.genome_to_organism_compact).fillna(
            growth_plot['Organism'])
        growth_plot = growth_plot.sort_values('Growth_Rate_hr-1')

        y_pos = np.arange(len(growth_plot))

        bar_colors = [DEEPSEA_PRIMARY['abyss'] if 'Marina' in name else DEEPSEA_PRIMARY['marine']
                      for name in growth_plot['Name']]
        bars = ax.barh(y_pos, growth_plot['Growth_Rate_hr-1'], color=bar_colors, alpha=0.8,
                       edgecolor=DEEPSEA_PRIMARY['abyss'], linewidth=0.5)

        ax.set_yticks(y_pos)
        ax.set_yticklabels(growth_plot['Name'], fontsize=10)

        for i, label in enumerate(ax.get_yticklabels()):
            organism_name = growth_plot.iloc[i]['Name']
            color = self.get_organism_color(organism_name)
            label.set_color(color)
            label.set_fontweight('bold')

        ax.set_xlabel('Growth Rate\n(hr⁻¹)', fontsize=11, color=DEEPSEA_PRIMARY['abyss'])
        ax.set_title('Growth Rates', fontsize=12, fontweight='bold', color=DEEPSEA_PRIMARY['abyss'])
        ax.grid(True, alpha=0.3, axis='x', color=DEEPSEA_SECONDARY['stone'])
        ax.set_facecolor(DEEPSEA_SECONDARY['pearl'])

        return growth_plot['Name'].tolist()

    def plot_metabolite_fluxes(self, ax, org_order):
        """Plot metabolite fluxes"""
        all_compounds = self.flux_data.groupby('Compound')['Abs_Flux'].sum().sort_values(ascending=False)
        top_compounds = all_compounds.head(15).index.tolist()

        flux_by_compound = []
        for organism in self.growth_data['Organism']:
            org_flux = self.flux_data[self.flux_data['Organism'] == organism]
            org_name = self.genome_to_organism_compact.get(organism, organism)
            row_data = {'Organism': org_name}

            for compound in top_compounds:
                compound_data = org_flux[org_flux['Compound'] == compound]
                uptake_flux = compound_data[compound_data['Direction'] == 'Uptake']['Flux_mmol/gDW/hr'].sum()
                secretion_flux = compound_data[compound_data['Direction'] == 'Secretion']['Flux_mmol/gDW/hr'].sum()
                row_data[f'{compound}_Uptake'] = uptake_flux
                row_data[f'{compound}_Secretion'] = secretion_flux
            flux_by_compound.append(row_data)

        flux_comp_df = pd.DataFrame(flux_by_compound)
        flux_comp_df['Organism'] = pd.Categorical(flux_comp_df['Organism'], categories=org_order, ordered=True)
        flux_comp_df = flux_comp_df.sort_values('Organism')

        uptake_colors = ['#004d00', '#006600', '#008000', '#009900', '#00b300',
                         '#00cc00', '#00e600', '#1aff1a', '#33ff33', '#4dff4d',
                         '#66ff66', '#80ff80', '#99ff99', '#b3ffb3', '#ccffcc']

        secretion_colors = [DEEPSEA_PRIMARY['abyss'], DEEPSEA_PRIMARY['midnight'], DEEPSEA_PRIMARY['deep_blue'],
                            DEEPSEA_PRIMARY['ocean'], DEEPSEA_PRIMARY['twilight'], DEEPSEA_PRIMARY['marine'],
                            DEEPSEA_PRIMARY['reef'], DEEPSEA_PRIMARY['lagoon'], DEEPSEA_PRIMARY['shallow'],
                            DEEPSEA_SECONDARY['current'], '#add8e6', '#87ceeb', '#87cefa', '#00bfff', '#1e90ff']

        left_uptake = np.zeros(len(flux_comp_df))
        right_secretion = np.zeros(len(flux_comp_df))
        y_pos = np.arange(len(flux_comp_df))

        legend_elements_uptake = []
        legend_elements_secretion = []

        for i, compound in enumerate(top_compounds):
            uptake_vals = flux_comp_df[f'{compound}_Uptake'].values
            secretion_vals = flux_comp_df[f'{compound}_Secretion'].values

            uptake_color = uptake_colors[i % len(uptake_colors)]
            secretion_color = secretion_colors[i % len(secretion_colors)]

            if np.any(uptake_vals < 0):
                ax.barh(y_pos, uptake_vals, left=left_uptake, color=uptake_color, alpha=0.8,
                        edgecolor='#003300', linewidth=0.1)
                left_uptake += uptake_vals
                if i < 8:
                    legend_elements_uptake.append(
                        plt.Rectangle((0, 0), 1, 1, facecolor=uptake_color, alpha=0.8,
                                      edgecolor='#003300', label=f'{compound} (in)'))

            if np.any(secretion_vals > 0):
                ax.barh(y_pos, secretion_vals, left=right_secretion, color=secretion_color, alpha=0.8,
                        edgecolor=DEEPSEA_PRIMARY['abyss'], linewidth=0.1)
                right_secretion += secretion_vals
                if i < 8:
                    legend_elements_secretion.append(
                        plt.Rectangle((0, 0), 1, 1, facecolor=secretion_color, alpha=0.8,
                                      edgecolor=DEEPSEA_PRIMARY['abyss'], label=f'{compound} (out)'))

        ax.set_yticks(y_pos)
        ax.set_yticklabels([])
        ax.set_xlabel('← Uptake (in) | Secretion (out) →\n(mmol/gDW/hr)', fontsize=11, color=DEEPSEA_PRIMARY['abyss'])
        ax.set_title('Compound Fluxes', fontsize=12, fontweight='bold', color=DEEPSEA_PRIMARY['abyss'])
        ax.axvline(x=0, color=DEEPSEA_PRIMARY['abyss'], linestyle='-', alpha=0.8, linewidth=1.5)
        ax.grid(True, alpha=0.3, axis='x', color=DEEPSEA_SECONDARY['stone'])
        ax.set_facecolor(DEEPSEA_SECONDARY['pearl'])

        all_legend_elements = legend_elements_uptake + legend_elements_secretion
        if all_legend_elements:
            legend = ax.legend(handles=all_legend_elements[:10], loc='lower right', fontsize=8, ncol=2,
                               frameon=True, fancybox=True, shadow=True,
                               bbox_to_anchor=(0.98, 0.02))
            legend.get_frame().set_facecolor(DEEPSEA_SECONDARY['pearl'])
            legend.get_frame().set_edgecolor(DEEPSEA_SECONDARY['stone'])

    def plot_reaction_categories(self, ax, org_order):
        """Plot reaction categories"""
        categories_data = []
        for organism_id in self.data['Organism'].unique():
            org_data = self.data[self.data['Organism'] == organism_id]
            org_name = self.genome_to_organism_compact.get(organism_id, f'Organism_{organism_id}')

            total = len(org_data)
            gapfilled = (org_data['Is_Gapfilled'] == True).sum()
            gapfilled_active = (org_data['Is_Gapfilled_Active'] == True).sum()
            gapfilled_constrained = (org_data['Is_Gapfilled_Active_Highly_Constrained'] == True).sum()
            gapfilled_ko_sensitive = (org_data['Is_Gapfilled_Active_Highly_Constrained_KO_Sensitive'] == True).sum()

            categories_data.append({
                'Organism': org_name,
                'Original': total - gapfilled,
                'Gapfilled_Inactive': gapfilled - gapfilled_active,
                'Gapfilled_Active_Unconstrained': gapfilled_active - gapfilled_constrained,
                'Gapfilled_Constrained_KO_Insensitive': gapfilled_constrained - gapfilled_ko_sensitive,
                'Gapfilled_Constrained_KO_Sensitive': gapfilled_ko_sensitive
            })

        cat_df = pd.DataFrame(categories_data)
        cat_df['Organism'] = pd.Categorical(cat_df['Organism'], categories=org_order, ordered=True)
        cat_df = cat_df.sort_values('Organism')

        bottom = np.zeros(len(cat_df))
        gap_colors = [DEEPSEA_SECONDARY['fog'],
                      DEEPSEA_PRIMARY['shallow'],
                      DEEPSEA_PRIMARY['lagoon'],
                      DEEPSEA_PRIMARY['marine'],
                      DEEPSEA_PRIMARY['abyss']]
        gap_labels = ['Original', 'Gapfilled Inactive', 'Gapfilled Active Unconstrained',
                      'Gapfilled Constrained', 'Gapfilled Constrained KO Sensitive']
        y_pos = np.arange(len(cat_df))

        for col, color, label in zip(['Original', 'Gapfilled_Inactive', 'Gapfilled_Active_Unconstrained',
                                      'Gapfilled_Constrained_KO_Insensitive', 'Gapfilled_Constrained_KO_Sensitive'],
                                     gap_colors, gap_labels):
            values = cat_df[col].values
            ax.barh(y_pos, values, left=bottom, color=color, alpha=0.8,
                    edgecolor=DEEPSEA_PRIMARY['abyss'], linewidth=0.3, label=label)
            bottom += values

        ax.set_yticks(y_pos)
        ax.set_yticklabels([])
        ax.set_xlabel('Number of\n Reactions', fontsize=11, color=DEEPSEA_PRIMARY['abyss'])
        ax.set_title('Gapfilling', fontsize=12, fontweight='bold', color=DEEPSEA_PRIMARY['abyss'])
        ax.grid(True, alpha=0.3, axis='x', color=DEEPSEA_SECONDARY['stone'])
        ax.set_facecolor(DEEPSEA_SECONDARY['pearl'])

        legend = ax.legend(loc='best', fontsize=9, frameon=True, fancybox=True, shadow=True)
        legend.get_frame().set_facecolor(DEEPSEA_SECONDARY['pearl'])
        legend.get_frame().set_edgecolor(DEEPSEA_SECONDARY['stone'])

    def plot_combined_three_plots(self):
        """Create combined plot with all three barplots using ocean colors"""
        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(24, 8))
        fig.patch.set_facecolor('white')

        org_order = self.plot_growth_rates(ax1)
        self.plot_metabolite_fluxes(ax2, org_order)
        self.plot_reaction_categories(ax3, org_order)

        legend_elements = [
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Pseudomonadota'],
                   markersize=10, label='Pseudomonadota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Acidobacteriota'],
                   markersize=10, label='Acidobacteriota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Bacteroidota'],
                   markersize=10, label='Bacteroidota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Actinomycetota'],
                   markersize=10, label='Actinomycetota')
        ]

        legend = fig.legend(handles=legend_elements, loc='upper center', ncol=4, title='Phylum',
                            frameon=True, fancybox=True, shadow=True, bbox_to_anchor=(0.5, 0.95))
        legend.get_frame().set_facecolor(DEEPSEA_SECONDARY['pearl'])
        legend.get_frame().set_edgecolor(DEEPSEA_SECONDARY['stone'])

        plt.suptitle('Metabolic Model Analysis Summary', fontsize=14, fontweight='bold', y=0.98,
                     color=DEEPSEA_PRIMARY['abyss'])
        plt.subplots_adjust(wspace=0.05)
        plt.show()

    def create_uniquely_gapfilled_upset_plot(self):
        """Create UpSet plot for uniquely gapfilled reactions"""
        gapfilled_data = self.data[self.data['Is_Gapfilled'] == True]
        organism_reaction_sets = {}

        for organism_id in gapfilled_data['Organism'].unique():
            organism_name = self.genome_to_organism_compact.get(organism_id, f'Organism_{organism_id}')
            reactions = set(gapfilled_data[gapfilled_data['Organism'] == organism_id]['Reaction_ID'])
            if reactions:
                organism_reaction_sets[organism_name] = reactions

        if not organism_reaction_sets:
            return None

        upset_data = from_contents(organism_reaction_sets)

        fig = plt.figure(figsize=(10, 6))
        fig.patch.set_facecolor('white')
        upset = UpSet(upset_data, subset_size='count', intersection_plot_elements=30,
                      show_counts=True, sort_by='cardinality', min_subset_size=5,
                      facecolor=DEEPSEA_PRIMARY['marine'])

        upset.plot(fig=fig)

        try:
            for ax in fig.get_axes():
                if hasattr(ax, 'get_yticklabels'):
                    labels = ax.get_yticklabels()
                    if labels and len(labels) > 0:
                        first_text = labels[0].get_text()
                        if first_text in organism_reaction_sets.keys():
                            for label in labels:
                                organism_name = label.get_text()
                                color = self.get_organism_color(organism_name)
                                label.set_color(color)
                                label.set_fontweight('bold')
                                label.set_fontsize(10)
        except:
            pass

        plt.suptitle('Gapfilled Reactions Analysis - Unique Requirements', fontsize=14, fontweight='bold',
                     color=DEEPSEA_PRIMARY['abyss'])

        marino_gapfilled = gapfilled_data[gapfilled_data['Organism'] == 'Marinacidobacteraceae']
        marino_constrained = marino_gapfilled[marino_gapfilled['Is_Gapfilled_Active_Highly_Constrained'] == True]

        all_marino_gapfilled = set(marino_gapfilled['Reaction_ID'])
        marino_constrained_reactions = set(marino_constrained['Reaction_ID'])
        other_gapfilled = set(gapfilled_data[gapfilled_data['Organism'] != 'Marinacidobacteraceae']['Reaction_ID'])

        uniquely_gapfilled_all = len(all_marino_gapfilled - other_gapfilled)
        uniquely_gapfilled_constrained = len(marino_constrained_reactions - other_gapfilled)

        total_reactions = len(gapfilled_data['Reaction_ID'].unique())
        fig.text(0.5, 0.95,
                 f'Total gapfilled: {total_reactions} | Marinacidobacterium: {len(all_marino_gapfilled)} (unique: {uniquely_gapfilled_all}, constrained-unique: {uniquely_gapfilled_constrained})',
                 ha='center', fontsize=11, style='italic', color=DEEPSEA_SECONDARY['depth'])

        legend_elements = [
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Pseudomonadota'],
                   markersize=10, label='Pseudomonadota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Acidobacteriota'],
                   markersize=10, label='Acidobacteriota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Bacteroidota'],
                   markersize=10, label='Bacteroidota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Actinomycetota'],
                   markersize=10, label='Actinomycetota')
        ]

        legend = fig.legend(handles=legend_elements, loc='upper right', title='Phylum',
                            frameon=True, fancybox=True, shadow=True)
        legend.get_frame().set_facecolor(DEEPSEA_SECONDARY['pearl'])
        legend.get_frame().set_edgecolor(DEEPSEA_SECONDARY['stone'])

        plt.tight_layout(rect=[0, 0, 1, 0.94])
        plt.show()

    def create_constrained_upset_plot(self):
        """Create UpSet plot for highly constrained gapfilled reactions"""
        constrained_data = self.data[self.data['Is_Gapfilled_Active_Highly_Constrained'] == True]
        organism_reaction_sets = {}

        for organism_id in constrained_data['Organism'].unique():
            organism_name = self.genome_to_organism_compact.get(organism_id, f'Organism_{organism_id}')
            reactions = set(constrained_data[constrained_data['Organism'] == organism_id]['Reaction_ID'])
            if reactions:
                organism_reaction_sets[organism_name] = reactions

        if not organism_reaction_sets:
            return None

        upset_data = from_contents(organism_reaction_sets)

        fig = plt.figure(figsize=(10, 3))
        fig.patch.set_facecolor('white')
        upset = UpSet(upset_data, subset_size='count', intersection_plot_elements=10,
                      show_counts=True, sort_by='cardinality', min_subset_size=4, element_size=20,
                      facecolor=DEEPSEA_PRIMARY['ocean'])

        upset.plot(fig=fig)

        try:
            for ax in fig.get_axes():
                if hasattr(ax, 'get_yticklabels'):
                    labels = ax.get_yticklabels()
                    if labels and len(labels) > 0:
                        first_text = labels[0].get_text()
                        if first_text in organism_reaction_sets.keys():
                            for label in labels:
                                organism_name = label.get_text()
                                color = self.get_organism_color(organism_name)
                                label.set_color(color)
                                label.set_fontweight('bold')
                                label.set_fontsize(10)
        except:
            pass

        plt.suptitle('Highly Constrained Reaction Intersections', fontsize=14, fontweight='bold',
                     color=DEEPSEA_PRIMARY['abyss'])

        total_reactions = len(constrained_data['Reaction_ID'].unique())
        total_organisms = len(organism_reaction_sets)
        fig.text(0.5, 0.95, f'Total constrained reactions: {total_reactions} | Organisms: {total_organisms}',
                 ha='center', fontsize=11, style='italic', color=DEEPSEA_SECONDARY['depth'])

        legend_elements = [
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Pseudomonadota'],
                   markersize=10, label='Pseudomonadota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Acidobacteriota'],
                   markersize=10, label='Acidobacteriota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Bacteroidota'],
                   markersize=10, label='Bacteroidota'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor=self.phylum_colors['Actinomycetota'],
                   markersize=10, label='Actinomycetota')
        ]

        legend = fig.legend(handles=legend_elements, loc='upper right', title='Phylum',
                            frameon=True, fancybox=True, shadow=True)
        legend.get_frame().set_facecolor(DEEPSEA_SECONDARY['pearl'])
        legend.get_frame().set_edgecolor(DEEPSEA_SECONDARY['stone'])

        plt.tight_layout(rect=[0, 0, 1, 0.94])
        plt.show()

    def create_pathway_enrichment_dot_plot(self):
        """Create metacyc pathway enrichment dot plot  (Fisher's exact test)"""
        if self.pathway_enrichment is None or len(self.pathway_enrichment) == 0:
            return

        sig_data = self.pathway_enrichment[
            (self.pathway_enrichment['P_Value'] < 0.05) &
            (self.pathway_enrichment['Fold_Enrichment'] > 1.2)
            ].head(30)

        if len(sig_data) == 0:
            return

        sig_data = sig_data.sort_values('Fold_Enrichment', ascending=True)

        fig, ax = plt.subplots(figsize=(12, 10))
        fig.patch.set_facecolor('white')
        ax.set_facecolor(DEEPSEA_SECONDARY['pearl'])

        colors = []
        for p_val in sig_data['P_Value']:
            if p_val < 0.001:
                colors.append(DEEPSEA_PRIMARY['abyss'])
            elif p_val < 0.01:
                colors.append(DEEPSEA_PRIMARY['midnight'])
            elif p_val < 0.05:
                colors.append(DEEPSEA_PRIMARY['marine'])
            else:
                colors.append(DEEPSEA_PRIMARY['lagoon'])

        y_positions = np.arange(len(sig_data))
        dot_sizes = sig_data['Unique_Count'] * 30
        scatter = ax.scatter(sig_data['FDR_Corrected_P'], y_positions,
                             c=colors, s=dot_sizes, alpha=0.8,
                             edgecolors=DEEPSEA_PRIMARY['abyss'], linewidth=0.8, zorder=5)

        for i, (_, row) in enumerate(sig_data.iterrows()):
            ax.annotate(f"{int(row['Unique_Count'])}/{int(row['Background_Count'])}",
                        xy=(row['FDR_Corrected_P'], i),
                        xytext=(8, 0), textcoords='offset points',
                        ha='left', va='center',
                        fontsize=9, fontweight='bold',
                        color=DEEPSEA_PRIMARY['abyss'])

        ax.set_yticks(y_positions)
        pathway_names = [name[:60] + '...' if len(name) > 60 else name for name in sig_data['Pathway']]
        ax.set_yticklabels(pathway_names, fontsize=10, fontweight='bold')

        ax.set_xscale('log')
        ax.set_xlabel('FDR-corrected P-value', fontsize=12, fontweight='bold', color=DEEPSEA_PRIMARY['abyss'])
        ax.set_ylabel('Metacyc Pathways', fontsize=12, fontweight='bold', color=DEEPSEA_PRIMARY['abyss'])
        ax.set_title(
            'Metacyc Pathway Enrichment \nMarinacidobacterium - Unique Constrained Reactions\n(Background: All Constrained Gapfilled Reactions)',
            fontsize=13, fontweight='bold', pad=20, color=DEEPSEA_PRIMARY['abyss'])

        ax.axvline(x=0.05, color=DEEPSEA_PRIMARY['abyss'], linestyle='--', alpha=0.6, linewidth=2, zorder=1,
                   label='FDR = 0.05')
        ax.axvline(x=0.01, color=DEEPSEA_SECONDARY['depth'], linestyle=':', alpha=0.5, linewidth=1.5, zorder=1,
                   label='FDR = 0.01')
        ax.axvline(x=0.001, color=DEEPSEA_SECONDARY['stone'], linestyle=':', alpha=0.5, linewidth=1.5, zorder=1,
                   label='FDR = 0.001')

        ax.grid(True, alpha=0.3, axis='x', color=DEEPSEA_SECONDARY['stone'])
        ax.set_axisbelow(True)

        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=DEEPSEA_PRIMARY['abyss'],
                       markersize=8, alpha=0.8, markeredgecolor=DEEPSEA_PRIMARY['abyss'],
                       label='P < 0.001', linewidth=0),
            plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=DEEPSEA_PRIMARY['midnight'],
                       markersize=8, alpha=0.8, markeredgecolor=DEEPSEA_PRIMARY['abyss'],
                       label='0.001 ≤ P < 0.01', linewidth=0),
            plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=DEEPSEA_PRIMARY['marine'],
                       markersize=8, alpha=0.8, markeredgecolor=DEEPSEA_PRIMARY['abyss'],
                       label='0.01 ≤ P < 0.05', linewidth=0)
        ]

        legend = ax.legend(handles=legend_elements, title='P-value',
                           loc='lower right', frameon=True, fancybox=True, shadow=True,
                           title_fontsize=11, fontsize=10)
        legend.get_frame().set_facecolor(DEEPSEA_SECONDARY['pearl'])
        legend.get_frame().set_edgecolor(DEEPSEA_SECONDARY['stone'])

        ax.set_xlim([sig_data['FDR_Corrected_P'].max() * 10, sig_data['FDR_Corrected_P'].min() / 10])

        plt.tight_layout()
        plt.show()

    def run_complete_analysis(self):
        """Run the complete knockout-based analysis with ocean colors and Fisher's exact test."""
        if not self.load_knockout_data():
            return False

        self.plot_combined_three_plots()
        self.create_uniquely_gapfilled_upset_plot()
        self.create_constrained_upset_plot()
        self.create_pathway_enrichment_dot_plot()

        return True


# ==================== MAIN FUNCTION ====================

def main():
    """Main function"""
    analyzer = KnockoutUnifiedAnalyzer()
    return analyzer.run_complete_analysis()


# ==================== EXECUTION ====================

if __name__ == "__main__":
    main()